{"ast":null,"code":"import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js';\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js';\nimport { ClientError } from '../classes/ClientError.js';\nimport { cleanQuery, isGraphQLContentType, isRequestResultHaveErrors, parseGraphQLExecutionResult } from '../lib/graphql.js';\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js';\n// @ts-expect-error todo\nexport const runRequest = async input => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`\n    }\n  };\n  const fetcher = createFetcher(config.method);\n  const fetchResponse = await fetcher(config);\n  // Parse response body FIRST, regardless of HTTP status\n  // This allows GraphQL errors to be extracted even when HTTP status is 4xx/5xx (fixes #1281)\n  let result;\n  try {\n    result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);\n  } catch (error) {\n    // If parsing fails, we'll handle it below based on HTTP status\n    result = error;\n  }\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers\n  };\n  // Handle non-2xx HTTP status codes\n  if (!fetchResponse.ok) {\n    if (result instanceof Error) {\n      // Parse failed - return ClientError without GraphQL data\n      // Still returns ClientError (not generic Error) to allow status code access\n      return new ClientError({\n        ...clientResponseBase\n      }, {\n        query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n        variables: input.request.variables\n      });\n    }\n    // Parse succeeded - return ClientError WITH GraphQL errors/data (fixes #1281)\n    const clientResponse = result._tag === `Batch` ? {\n      ...result.executionResults,\n      ...clientResponseBase\n    } : {\n      ...result.executionResult,\n      ...clientResponseBase\n    };\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  // For 2xx responses, parse errors should throw\n  if (result instanceof Error) throw result;\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch` ? {\n      ...result.executionResults,\n      ...clientResponseBase\n    } : {\n      ...result.executionResult,\n      ...clientResponseBase\n    };\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables\n    });\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult)\n      };\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config))\n      };\n    default:\n      casesExhausted(result);\n  }\n};\nconst executionResultClientResponseFields = $params => executionResult => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined\n  };\n};\nconst parseResultFromResponse = async (response, jsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER);\n  const text = await response.text();\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text));\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text);\n  }\n};\nconst createFetcher = method => async params => {\n  const headers = new Headers(params.headers);\n  let searchParams = null;\n  let body = undefined;\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));\n  }\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n    body = $jsonSerializer.stringify(buildBody(params));\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);\n    }\n  } else {\n    searchParams = buildQueryParams(params);\n  }\n  const init = {\n    method,\n    headers,\n    body,\n    ...params.fetchOptions\n  };\n  let url = new URL(params.url);\n  let initResolved = init;\n  if (params.middleware) {\n    const result = await Promise.resolve(params.middleware({\n      ...init,\n      url: params.url,\n      operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n      variables: params.request.variables\n    }));\n    const {\n      url: urlNew,\n      ...initNew\n    } = result;\n    url = new URL(urlNew);\n    initResolved = initNew;\n  }\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value);\n    });\n  }\n  const $fetch = params.fetch ?? fetch;\n  return await $fetch(url, initResolved);\n};\nconst buildBody = params => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName\n      };\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables\n      }));\n    default:\n      throw casesExhausted(params.request);\n  }\n};\nconst buildQueryParams = params => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;\n  const searchParams = new URLSearchParams();\n  switch (params.request._tag) {\n    case `Single`:\n      {\n        searchParams.append(`query`, cleanQuery(params.request.document.expression));\n        if (params.request.variables) {\n          searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));\n        }\n        if (params.request.document.operationName) {\n          searchParams.append(`operationName`, params.request.document.operationName);\n        }\n        return searchParams;\n      }\n    case `Batch`:\n      {\n        const variablesSerialized = params.request.variables?.map(v => $jsonSerializer.stringify(v)) ?? [];\n        const queriesCleaned = params.request.query.map(cleanQuery);\n        const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n          query,\n          variables\n        }));\n        searchParams.append(`query`, $jsonSerializer.stringify(payload));\n        return searchParams;\n      }\n    default:\n      throw casesExhausted(params.request);\n  }\n};","map":{"version":3,"names":["ACCEPT_HEADER","CONTENT_TYPE_GQL","CONTENT_TYPE_HEADER","CONTENT_TYPE_JSON","casesExhausted","uppercase","zip","ClientError","cleanQuery","isGraphQLContentType","isRequestResultHaveErrors","parseGraphQLExecutionResult","defaultJsonSerializer","runRequest","input","config","method","request","_tag","document","isMutation","hasMutations","fetchOptions","errorPolicy","fetcher","createFetcher","fetchResponse","result","parseResultFromResponse","jsonSerializer","error","clientResponseBase","status","headers","ok","Error","query","expression","variables","clientResponse","executionResults","executionResult","executionResultClientResponseFields","data","map","$params","extensions","errors","undefined","response","contentType","get","text","parse","params","Headers","searchParams","body","has","set","join","$jsonSerializer","stringify","buildBody","buildQueryParams","init","url","URL","initResolved","middleware","Promise","resolve","operationName","urlNew","initNew","forEach","value","name","append","$fetch","fetch","URLSearchParams","variablesSerialized","v","queriesCleaned","payload"],"sources":["C:\\Users\\porta\\OneDrive\\Documentos\\Univalle\\MercaDEA\\Panel-Amin-Nuevo\\node_modules\\graphql-request\\src\\legacy\\helpers\\runRequest.ts"],"sourcesContent":["import { ACCEPT_HEADER, CONTENT_TYPE_GQL, CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON } from '../../lib/http.js'\nimport { casesExhausted, uppercase, zip } from '../../lib/prelude.js'\nimport { ClientError } from '../classes/ClientError.js'\nimport type { GraphQLExecutionResultSingle } from '../lib/graphql.js'\nimport {\n  cleanQuery,\n  isGraphQLContentType,\n  isRequestResultHaveErrors,\n  parseGraphQLExecutionResult,\n} from '../lib/graphql.js'\nimport { defaultJsonSerializer } from './defaultJsonSerializer.js'\nimport type {\n  BatchVariables,\n  Fetch,\n  FetchOptions,\n  GraphQLClientResponse,\n  HTTPMethodInput,\n  JsonSerializer,\n  RequestMiddleware,\n  Variables,\n} from './types.js'\n\ninterface Input {\n  url: string\n  /**\n   * The HTTP method to use for queries. Note that mutations are ALWAYS sent as POST requests ([per spec](https://github.com/graphql/graphql-over-http/blob/main/spec/GraphQLOverHTTP.md?rgh-link-date=2022-06-02T09%3A30%3A53Z)).\n   *\n   * @defaultValue `'POST'`\n   */\n  method?: HTTPMethodInput\n  fetch?: Fetch\n  fetchOptions: FetchOptions\n  headers?: HeadersInit\n  middleware?: RequestMiddleware\n  request:\n    | {\n      _tag: 'Single'\n      variables?: Variables\n      document: {\n        expression: string\n        isMutation: boolean\n        operationName?: string\n      }\n    }\n    | {\n      _tag: 'Batch'\n      query: string[]\n      operationName?: undefined\n      hasMutations: boolean\n      variables?: BatchVariables\n    }\n}\n\n// @ts-expect-error todo\nexport const runRequest = async (input: Input): Promise<ClientError | GraphQLClientResponse<any>> => {\n  // todo make a Config type\n  const config = {\n    ...input,\n    method: input.request._tag === `Single`\n      ? input.request.document.isMutation\n        ? `POST`\n        : uppercase(input.method ?? `post`)\n      : input.request.hasMutations\n      ? `POST`\n      : uppercase(input.method ?? `post`),\n    fetchOptions: {\n      ...input.fetchOptions,\n      errorPolicy: input.fetchOptions.errorPolicy ?? `none`,\n    },\n  }\n  const fetcher = createFetcher(config.method)\n  const fetchResponse = await fetcher(config)\n\n  // Parse response body FIRST, regardless of HTTP status\n  // This allows GraphQL errors to be extracted even when HTTP status is 4xx/5xx (fixes #1281)\n  let result\n  try {\n    result = await parseResultFromResponse(\n      fetchResponse,\n      input.fetchOptions.jsonSerializer ?? defaultJsonSerializer,\n    )\n  } catch (error) {\n    // If parsing fails, we'll handle it below based on HTTP status\n    result = error as Error\n  }\n\n  const clientResponseBase = {\n    status: fetchResponse.status,\n    headers: fetchResponse.headers,\n  }\n\n  // Handle non-2xx HTTP status codes\n  if (!fetchResponse.ok) {\n    if (result instanceof Error) {\n      // Parse failed - return ClientError without GraphQL data\n      // Still returns ClientError (not generic Error) to allow status code access\n      return new ClientError(\n        { ...clientResponseBase },\n        {\n          query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n          variables: input.request.variables,\n        },\n      )\n    }\n\n    // Parse succeeded - return ClientError WITH GraphQL errors/data (fixes #1281)\n    const clientResponse = result._tag === `Batch`\n      ? { ...result.executionResults, ...clientResponseBase }\n      : {\n        ...result.executionResult,\n        ...clientResponseBase,\n      }\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables,\n    })\n  }\n\n  // For 2xx responses, parse errors should throw\n  if (result instanceof Error) throw result\n\n  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {\n    // todo this client response on error is not consistent with the data type for success\n    const clientResponse = result._tag === `Batch`\n      ? { ...result.executionResults, ...clientResponseBase }\n      : {\n        ...result.executionResult,\n        ...clientResponseBase,\n      }\n    // @ts-expect-error todo\n    return new ClientError(clientResponse, {\n      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,\n      variables: input.request.variables,\n    })\n  }\n  switch (result._tag) {\n    case `Single`:\n      // @ts-expect-error todo\n      return {\n        ...clientResponseBase,\n        ...executionResultClientResponseFields(config)(result.executionResult),\n      }\n    case `Batch`:\n      return {\n        ...clientResponseBase,\n        data: result.executionResults.map(executionResultClientResponseFields(config)),\n      }\n    default:\n      casesExhausted(result)\n  }\n}\n\nconst executionResultClientResponseFields = ($params: Input) => (executionResult: GraphQLExecutionResultSingle) => {\n  return {\n    extensions: executionResult.extensions,\n    data: executionResult.data,\n    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : undefined,\n  }\n}\n\nconst parseResultFromResponse = async (response: Response, jsonSerializer: JsonSerializer) => {\n  const contentType = response.headers.get(CONTENT_TYPE_HEADER)\n  const text = await response.text()\n  if (contentType && isGraphQLContentType(contentType)) {\n    return parseGraphQLExecutionResult(jsonSerializer.parse(text))\n  } else {\n    // todo what is this good for...? Seems very random/undefined\n    return parseGraphQLExecutionResult(text)\n  }\n}\n\nconst createFetcher = (method: 'GET' | 'POST') => async (params: Input) => {\n  const headers = new Headers(params.headers)\n  let searchParams: URLSearchParams | null = null\n  let body = undefined\n\n  if (!headers.has(ACCEPT_HEADER)) {\n    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `))\n  }\n\n  if (method === `POST`) {\n    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n    body = $jsonSerializer.stringify(buildBody(params))\n    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {\n      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON)\n    }\n  } else {\n    searchParams = buildQueryParams(params)\n  }\n\n  const init: RequestInit = { method, headers, body, ...params.fetchOptions }\n\n  let url = new URL(params.url)\n  let initResolved = init\n\n  if (params.middleware) {\n    const result = await Promise.resolve(\n      params.middleware({\n        ...init,\n        url: params.url,\n        operationName: params.request._tag === `Single` ? params.request.document.operationName : undefined,\n        variables: params.request.variables,\n      }),\n    )\n    const { url: urlNew, ...initNew } = result\n    url = new URL(urlNew)\n    initResolved = initNew\n  }\n\n  if (searchParams) {\n    searchParams.forEach((value, name) => {\n      url.searchParams.append(name, value)\n    })\n  }\n\n  const $fetch = params.fetch ?? fetch\n  return await $fetch(url, initResolved)\n}\n\nconst buildBody = (params: Input) => {\n  switch (params.request._tag) {\n    case `Single`:\n      return {\n        query: params.request.document.expression,\n        variables: params.request.variables,\n        operationName: params.request.document.operationName,\n      }\n    case `Batch`:\n      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n\nconst buildQueryParams = (params: Input): URLSearchParams => {\n  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer\n  const searchParams = new URLSearchParams()\n  switch (params.request._tag) {\n    case `Single`: {\n      searchParams.append(`query`, cleanQuery(params.request.document.expression))\n      if (params.request.variables) {\n        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables))\n      }\n      if (params.request.document.operationName) {\n        searchParams.append(`operationName`, params.request.document.operationName)\n      }\n      return searchParams\n    }\n    case `Batch`: {\n      const variablesSerialized = params.request.variables?.map((v) => $jsonSerializer.stringify(v)) ?? []\n      const queriesCleaned = params.request.query.map(cleanQuery)\n      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({\n        query,\n        variables,\n      }))\n      searchParams.append(`query`, $jsonSerializer.stringify(payload))\n      return searchParams\n    }\n    default:\n      throw casesExhausted(params.request)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}